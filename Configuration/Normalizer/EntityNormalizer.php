<?php

/*
 * This file is part of the EasyAdminBundle.
 *
 * (c) Javier Eguiluz <javier.eguiluz@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace JavierEguiluz\Bundle\EasyAdminBundle\Configuration\Normalizer;

/**
 * Transforms the two simple configuration formats into the full expanded
 * configuration. This allows to reuse the same method to process any of the
 * different configuration formats.
 *
 * These are the two simple formats allowed:
 *
 * # Config format #1: no custom entity name
 * easy_admin:
 *     entities:
 *         - AppBundle\Entity\User
 *
 * # Config format #2: simple config with custom entity name
 * easy_admin:
 *     entities:
 *         User: AppBundle\Entity\User
 *
 * And this is the full expanded configuration syntax generated by this method:
 *
 * # Config format #3: expanded entity configuration with 'class' parameter
 * easy_admin:
 *     entities:
 *         User:
 *             class: AppBundle\Entity\User
 *
 * By default the entity name is used as its label (showed in buttons, the
 * main menu, etc.). That's why the config format #3 can optionally define
 * a custom entity label
 *
 * easy_admin:
 *     entities:
 *         User:
 *             class: AppBundle\Entity\User
 *             label: 'Clients'
 *
 *
 * @author Javier Eguiluz <javier.eguiluz@gmail.com>
 */
class EntityNormalizer implements NormalizerInterface
{
    public function normalize(array $backendConfiguration)
    {
        $normalizedConfiguration = array();
        $entityConfiguration = $backendConfiguration['entities'];

        foreach ($entityConfiguration as $entityName => $entityConfiguration) {
            // normalize config formats #1 and #2 to use the 'class' option as config format #3
            if (!is_array($entityConfiguration)) {
                $entityConfiguration = array('class' => $entityConfiguration);
            }

            // if config format #3 is used, ensure that it defines the 'class' option
            if (!isset($entityConfiguration['class'])) {
                throw new \RuntimeException(sprintf('The "%s" entity must define its associated Doctrine entity class using the "class" option.', $entityName));
            }

            // if config format #1 is used, the entity name is the numeric index
            // of the configuration array. In this case, autogenerate the entity
            // name using its class name
            if (is_numeric($entityName)) {
                $entityClassParts = explode('\\', $entityConfiguration['class']);
                $entityClassName = end($entityClassParts);
                $entityName = $this->getUniqueEntityName($entityClassName, array_keys($normalizedConfiguration));
            } else {
                // if config format #2 and #3 are used, make sure that the entity
                // name is valid as a PHP method name (this is required to allow
                // extending the backend with a custom controller)
                if (!$this->isValidMethodName($entityName)) {
                    throw new \InvalidArgumentException(sprintf('The name of the "%s" entity contains invalid characters (allowed: letters, numbers, underscores; the first character cannot be a number).', $entityName));
                }
            }

            // if config format #3 defines the 'label' option, use its value.
            // otherwise, use the entity name as its label
            if (!isset($entityConfiguration['label'])) {
                $entityConfiguration['label'] = $entityName;
            }

            $entityConfiguration['name'] = $entityName;
            $normalizedConfiguration[$entityName] = $entityConfiguration;
        }

        $backendConfiguration['entities'] = $normalizedConfiguration;

        return $backendConfiguration;
    }

    /**
     * Checks whether the given string is valid as a PHP method name.
     *
     * @param string $name
     *
     * @return bool
     */
    private function isValidMethodName($name)
    {
        return 0 !== preg_match('/^-?[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $name);
    }

    /**
     * The name of the entity is included in the URLs of the backend to define
     * the entity used to perform the operations. Obviously, the entity name
     * must be unique to identify entities unequivocally.
     *
     * This method ensures that the given entity name is unique among all the
     * previously existing entities passed as the second argument. This is
     * achieved by iteratively appending a suffix until the entity name is
     * guaranteed to be unique.
     *
     * @param string $entityName
     * @param array  $existingEntityNames
     *
     * @return string The entity name transformed to be unique
     */
    private function getUniqueEntityName($entityName, array $existingEntityNames)
    {
        $uniqueName = $entityName;

        $i = 2;
        while (in_array($uniqueName, $existingEntityNames)) {
            $uniqueName = $entityName.($i++);
        }

        return $uniqueName;
    }
}
