<?php

/*
 * This file is part of the EasyAdminBundle.
 *
 * (c) Javier Eguiluz <javier.eguiluz@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace JavierEguiluz\Bundle\EasyAdminBundle\DependencyInjection;

use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
use Symfony\Component\Config\FileLocator;

class EasyAdminExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        // process bundle's configuration parameters
        $backendConfiguration = $this->processConfiguration(new Configuration(), $configs);
        $backendConfiguration['entities'] = $this->getEntitiesConfiguration($backendConfiguration['entities']);

        $container->setParameter('easyadmin.config', $backendConfiguration);

        // load bundle's services
        $loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));
        $loader->load('services.xml');
    }

    /**
     * Processes, normalizes and initializes the configuration of the entities
     * that are managed by the backend. Several configuration formats are allowed,
     * so this method normalizes them all.
     *
     * @param  array $entitiesConfiguration
     * @return array The full entity configuration
     */
    public function getEntitiesConfiguration(array $entitiesConfiguration)
    {
        if (0 === count($entitiesConfiguration)) {
            return $entitiesConfiguration;
        }

        $configuration = $this->normalizeEntitiesConfiguration($entitiesConfiguration);
        $configuration = $this->processEntitiesConfiguration($configuration);
        //$configuration = $this->ensureThatEntityNamesAreUnique($configuration);

        return $configuration;
    }

    /**
     * Transforms the two simple configuration formats into the full expanded
     * configuration. This allows to reuse the same method to process any of the
     * different configuration formats.
     *
     * These are the two simple formats allowed:
     *
     * # Config format #1: no custom entity label
     * easy_admin:
     *     entities:
     *         - AppBundle\Entity\User
     *
     * # Config format #2: simple config with custom entity label
     * easy_admin:
     *     entities:
     *         User: AppBundle\Entity\User
     *
     * And this is the full expanded configuration syntax generated by this method:
     *
     * # Config format #3: expanded entity configuration with 'class' parameter
     * easy_admin:
     *     entities:
     *         User:
     *             class: AppBundle\Entity\User
     *
     * # Config format #3 can optionally define a custom entity label
     * easy_admin:
     *     entities:
     *         User:
     *             class: AppBundle\Entity\User
     *             label: 'Clients'
     *
     * @param  array $entitiesConfiguration The entity configuration in one of the simplified formats
     * @return array The normalized configuration
     */
    private function normalizeEntitiesConfiguration(array $entitiesConfiguration)
    {
        $normalizedConfiguration = array();

        foreach ($entitiesConfiguration as $entityLabel => $entityConfiguration) {
            // config formats #1 and #2
            if (!is_array($entityConfiguration)) {
                $entityConfiguration = array('class' => $entityConfiguration);
            }

            $entityClassParts = explode('\\', $entityConfiguration['class']);
            $entityClassName = end($entityClassParts);

            # if config format #3 defines the 'label' option, use its value.
            # otherwise, infer the entity label from its configuration.
            if (!isset($entityConfiguration['label'])) {
                // config format #1 doesn't define any entity label because configuration is
                // just a plain numeric array (the label is the integer key of that array).
                // In that case, use the entity class name as its label
                $entityConfiguration['label'] = is_integer($entityLabel) ? $entityClassName : $entityLabel;
            }

            $entityName = $this->getUniqueEntityName($entityClassName, array_keys($normalizedConfiguration));
            $entityConfiguration['name'] = $entityName;

            $normalizedConfiguration[$entityName] = $entityConfiguration;
        }

        return $normalizedConfiguration;
    }

    /**
     * Normalizes and initializes the configuration of the given entities to
     * simplify the option processing of the other methods and functions.
     *
     * @param  array $entitiesConfiguration
     * @return array The configured entities
     */
    private function processEntitiesConfiguration(array $entitiesConfiguration)
    {
        $entities = array();

        foreach ($entitiesConfiguration as $entityName => $entityConfiguration) {
            // copy the original entity configuration to not lose any of its options
            $config = $entityConfiguration;

            // if the common 'form' config is defined, use its options to complete
            // the configuration for the 'new' and 'edit' actions
            if (isset($config['form'])) {
                $config['new'] = isset($config['new']) ? array_replace($config['form'], $config['new']) : $config['form'];
                $config['edit'] = isset($config['edit']) ? array_replace($config['form'], $config['edit']) : $config['form'];
            }

            // configuration for the actions related to the entity ('list', 'edit', etc.)
            foreach (array('edit', 'list', 'new', 'show') as $action) {
                // if needed, initialize options to simplify further configuration processing
                if (!isset($config[$action])) {
                    $config[$action] = array('fields' => array());
                }

                if (!isset($config[$action]['fields'])) {
                    $config[$action]['fields'] = array();
                }

                if (count($config[$action]['fields']) > 0) {
                    $config[$action]['fields'] = $this->normalizeFieldsConfiguration($config[$action]['fields'], $action, $entityConfiguration);
                }
            }

            $entities[$entityName] = $config;
        }

        return $entities;
    }

    /**
     * The name of the entity is used in the URLs of the application to define the
     * entity which should be used for each action. Obviously, the entity name
     * must be unique in the application to identify entities unequivocally.
     *
     * This method ensures that all entity names are unique by appending some suffix
     * to repeated names until they are unique.
     *
     * @param  array $entitiesConfiguration
     * @return array The entities configuration with unique entity names
     */
    private function getUniqueEntityName($entityName, $existingEntityNames)
    {
        $uniqueName = $entityName;

        while (in_array($uniqueName, $existingEntityNames)) {
            $uniqueName .= '_';
        }

        return $uniqueName;
    }

    /**
     * Actions can define their fields using two different formats:
     *
     * # Config format #1: simple configuration
     * easy_admin:
     *     Client:
     *         # ...
     *         list:
     *             fields: ['id', 'name', 'email']
     *
     * # Config format #2: extended configuration
     * easy_admin:
     *     Client:
     *         # ...
     *         list:
     *             fields: ['id', 'name', { property: 'email', label: 'Contact' }]
     *
     * This method processes both formats to produce a common form field configuration
     * format used in the rest of the application.
     *
     * @param  array  $fieldsConfiguration
     * @param  string $action              The current action (this argument is needed to create good error messages)
     * @param  array  $entityConfiguration The full configuration of the entity this field belongs to
     * @return array  The configured entity fields
     */
    private function normalizeFieldsConfiguration(array $fieldsConfiguration, $action, array $entityConfiguration)
    {
        $fields = array();

        foreach ($fieldsConfiguration as $field) {
            if (is_string($field)) {
                // Config format #1: field is just a string representing the entity property
                $fieldConfiguration = array('property' => $field);
            } elseif (is_array($field)) {
                // Config format #1: field is an array that defines one or more
                // options. check that the mandatory 'property' option is set
                if (!array_key_exists('property', $field)) {
                    throw new \RuntimeException(sprintf('One of the values of the "fields" option for the "%s" action of the "%s" entity does not define the "property" option.', $action, $entityConfiguration['class']));
                }

                $fieldConfiguration = $field;
            } else {
                throw new \RuntimeException(sprintf('The values of the "fields" option for the "$s" action of the "%s" entity can only be strings or arrays.', $action, $entityConfiguration['class']));
            }

            // for 'image' type fields, if the entity defines an 'image_base_path'
            // option, but the field does not, use the value defined by the entity
            if (isset($fieldConfiguration['type']) && 'image' === $fieldConfiguration['type']) {
                if (!isset($fieldConfiguration['base_path']) && isset($entityConfiguration['image_base_path'])) {
                    $fieldConfiguration['base_path'] = $entityConfiguration['image_base_path'];
                }
            }

            $fieldName = $fieldConfiguration['property'];
            $fields[$fieldName] = $fieldConfiguration;
        }

        return $fields;
    }
}
